//
//  Data+HashingMethods.swift
//  Created by Amir Sepehrom on 5/31/21.
//

import Foundation
import Security
import CommonCrypto

extension SecKey {
    
    fileprivate subscript(attribute attr: CFString) -> Any? {
        let attributes = SecKeyCopyAttributes(self) as? [CFString: Any]
        return attributes?[attr]
    }
    
    /// Returns key length.
    public var keySize: Int {
        // swiftlint: disable force_cast
        return self[attribute: kSecAttrKeySizeInBits] as! Int
    }
    
    /// Returns encryption method of key.
    public var type: KeyType {
        // swiftlint: disable force_cast
        let type = self[attribute: kSecAttrType] as! CFString
        return KeyType(rawValue: type)!
    }
    
    /// Public ASN1 header appropriate for current key.
    fileprivate func asn1Header() throws -> Data {
        return try type.asn1Header(keySize: keySize)
    }
    
    /// Exporable key data with ASN1 header.
    public func bytes() throws -> Data {
        return try asn1Header() + rawBytes()
    }
    
    /// Raw bytes for key that generated by Security framework.
    public func rawBytes() throws -> Data {
        var error: Unmanaged<CFError>?
        
        guard let keyData = SecKeyCopyExternalRepresentation(self, &error) as Data? else {
            throw error?.takeRetainedValue() ?? CryptographyError.invalidKey
        }
        return keyData
    }
    
    /// Encryption method
    public enum KeyType: RawRepresentable {
        /// Eliptic curve
        case ec
        /// RSA
        case rsa
        
        /// Initilize from kSecAttrKeyType string constant.
        public init?(rawValue: CFString) {
            switch rawValue {
            case kSecAttrKeyTypeEC, kSecAttrKeyTypeECSECPrimeRandom:
                self = .ec
            case kSecAttrKeyTypeRSA:
                self = .rsa
            default:
                return nil
            }
        }
        
        /// kSecAttrKeyType counterpart of option.
        public var rawValue: CFString {
            switch self {
            case .ec:
                return kSecAttrKeyTypeECSECPrimeRandom
            case .rsa:
                return kSecAttrKeyTypeRSA
            }
        }
        
        /// ASN1 headers for encrypting public keys.
        public struct ASN1 {
            public static let rsa2048 = Data(base64Encoded: "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A")!
            public static let rsa4096 = Data(base64Encoded: "MIICIjANBgkqhkiG9w0BAQEFAAOCAg8A")!
            public static let ec256   = Data(base64Encoded: "MFkwEwYHKoZIzj0CAQYIKoZIzj0DAQcDQgA=")!
            public static let ec384   = Data(base64Encoded: "MHYwEAYHKoZIzj0CAQYFK4EEACIDYgA=")!
            public static let ec521   = Data(base64Encoded: "MIGbMBAGByqGSM49AgEGBSuBBAAjA4GGAA==")!
        }
        
        func asn1Header(keySize: Int) throws -> Data {
            switch (self, keySize) {
            case (.ec, 256):
                return ASN1.ec256
            case (.ec, 384):
                return ASN1.ec384
            case (.ec, 521):
                return ASN1.ec521
            case (.rsa, 2048):
                return ASN1.rsa2048
            case (.rsa, 4096):
                return ASN1.rsa4096
            default:
                throw CryptographyError.unsupported
            }
        }
    }
}

public enum CryptographyError: Error {
    /// Key data is not valid or not conform to expected type and length.
    case invalidKey
    /// Encryption failed.
    case failedEncryption
    /// Decryption failed.
    case failedDecryption
    /// Data that passed to encrypt/decrypt is empty.
    case emptyData
    /// Encrypted data is not valid or encrypted with another key type.
    case invalidData
    /// Encryption/Decryption method is not supported.
    case unsupported
    
    // Enclave
    /// Private key is not exist on the device enclave.
    case keyNotFound
    /// Operation with private key which saved in enclave is not posssible.
    case notAllowed
}

public enum Digest: String {
    case md5 = "MD5"
    case sha1 = "SHA1"
    case sha256 = "SHA256"
    case sha384 = "SHA384"
    case sha512 = "SHA512"
    
    public var length: Int {
        switch self {
        case .md5:
            return Int(CC_MD5_DIGEST_LENGTH)
        case .sha1:
            return Int(CC_SHA1_DIGEST_LENGTH)
        case .sha256:
            return Int(CC_SHA256_DIGEST_LENGTH)
        case .sha384:
            return Int(CC_SHA384_DIGEST_LENGTH)
        case .sha512:
            return Int(CC_SHA512_DIGEST_LENGTH)
        }
    }
    
    public var hmacAlgorithm: CCHmacAlgorithm {
        switch self {
        case .md5:
            return CCHmacAlgorithm(kCCHmacAlgMD5)
        case .sha1:
            return CCHmacAlgorithm(kCCHmacAlgSHA1)
        case .sha256:
            return CCHmacAlgorithm(kCCHmacAlgSHA256)
        case .sha384:
            return CCHmacAlgorithm(kCCHmacAlgSHA384)
        case .sha512:
            return CCHmacAlgorithm(kCCHmacAlgSHA512)
        }
    }
}

extension Data {
    /**
     Calculates hash digest of data.
     
     - Parameter digest: digest type. Currently only SHA is supported.
     - Returns: A data object with length equal to digest length.
     */
    public func hash(digest: Digest) -> Data {
        guard !isEmpty else { return Data() }
        var result = [UInt8](repeating: 0, count: digest.length)
        self.withUnsafeBytes { (buf: UnsafeRawBufferPointer) -> Void in
            let ptr = buf.baseAddress!
            let dataLen = CC_LONG(buf.count)
            switch digest {
            case .md5:
                CC_MD5(ptr, dataLen, &result)
            case .sha1:
                CC_SHA1(ptr, dataLen, &result)
            case .sha256:
                CC_SHA256(ptr, dataLen, &result)
            case .sha384:
                CC_SHA384(ptr, dataLen, &result)
            case .sha512:
                CC_SHA512(ptr, dataLen, &result)
            }
        }
        
        return Data(result)
    }
}
